#-------------------------------------------------------------------------------
# Imports
#-------------------------------------------------------------------------------

import time

import ipython1.kernel.api as kernel

rc = kernel.RemoteController(('127.0.0.1',10105))

#-------------------------------------------------------------------------------
# Setup
#-------------------------------------------------------------------------------

rc = client(('127.0.0.1',10105))
rc.activate()
rc.block = True
rc.getIDs()
assert len(rc) >= 4

#-------------------------------------------------------------------------------
# Blocking execution
#-------------------------------------------------------------------------------

# Execute

rc.iexecuteAll('a=5')
rc.iexecute([0,2],'b=10')
rc.iexecute([1,3],'b=20')
rc.iexecuteAll('c=a*b')

# Magics

%px import math
%px a = math.sin(math.pi)

%autopx

import math
def compute(x):
    return math.pow(x, 2.0)


%autopx


for i in rc.getIDs():
    rc.iexecute(i, 'myresult = compute(%i)' % i)

%result

# Push/pull

rc.pushAll(a=10, b=20)
rc.pullAll('a', 'b')
rc.pullAll('a')
rc.push([0,1], c=range(5))
rc.push([2,3], c=range(5))
rc.pullAll('c')

# getResult/reset

rc.iexecuteAll('import math; print math.pi')
rc.igetResultAll()
rc.resetAll()
rc.iexecuteAll('a=5')
rc.iexecuteAll('b=10')
rc.igetResultAll(0)
rc.igetResultAll(1)
print "keys: ", rc.keysAll()

# Queue management

c.iexecuteAll('import time')
for i in range(100):
    c.iexecuteAll('time.sleep(0.01)', block=False)


c.iqueueStatusAll()
c.clearQueueAll()
c.iqueueStatusAll()

# scatter/gather

c.scatterAll('a', range(20))
c.gatherAll('a')

# map

c.mapAll('lambda x: 2.0*x', range(20))

# Using the .r attribute to simplify computations
ipc.block = False
ipc.executeAll('x=1')
x = ipc.pullAll('x')
x = x.r  # this will block
print sum(x)



