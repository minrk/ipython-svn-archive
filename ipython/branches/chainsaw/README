===========================
IPython Kernel README
===========================

:Author:  Brian E. Granger
:Contact: ellisonbg@gmail.com
:Date: July, 2006

.. contents::

Overview
========

This file gives an overview of the IPython kernel.  The IPython kernel exposes Python over the network and allows parallel and distributed applications to be developed, debugged, tested, executed and monitored interactively and collaboratively.

For installation instructions, see the INSTALL file in this directory.

The IPython kernel is a component of a future release of IPython - IPython1.  While IPython1 is not completed the kernel module is fully functional and can be used from the current stable IPython versions.  

The IPython kernel is essentially a network enabled Python instance.  The kernel actually consists of three components:

:IPython Engine: The IPython Engine is a Python instance that takes Python commands over a network connection.  Eventually, the IPython Engine will be an IPython instance, but for now, it is plain Python.  The Engine can also handle incoming and outgoing Python objects send over a network connection.  When multiple Engines are started, parallel and distributed computing becomes possible.  An important feature of the IPython Engines is that they block while user code is being executed.  
:IPython Controller: The IPython Controller provides an interface for working with a set of Engines.  It manages a queue for each Engine and exposes a fully asynchronous interface to each Engine.  Because the Controller listens on a network port for Engines to connect to it, it must be started before any Engines are started.  The Controller also provides a single point of contact for users who wish to utilize the Engines connected to the Controller.
:Controller Clients: Various Controller clients provide a way for users to interact with a Controller, and thus, with a set of Engines.  Our default client is RemoteController Python object that is designed to be used from within Python or IPython.  It be used both interactively and in scripts.  

Getting Started
===============

Starting the Controller
-----------------------

The IPython Controller can be started with the command:

::

	ipcontroller
	
This will start a controller that listens on the default ports for connections from Engines and Clients.  To see command line options for the Controller give the command:

::

	ipcontroller -h

The details of the Controller (which ports are used, etc.) can also be configured using configuration files. 

Starting Engines
----------------

Instances of the IPython Engine can be started with the command:

::

	ipengine
	
Upon starting, the Engine should automatically connect to the Controller and register itself.  As long as the Controller was started with the default ports, the Engines should find the Controller just fine.  Multiple instances of the Engine can be started on a single machine or on multiple machines.  A single Controller can handle up to 256 Engines, but this number is somewhat dependent on OS related limits on the number of file descriptors per process.

Like the Controller, the Engine can be configured using command line options and configuration files.

To run an Engine in the background, you may need to issue the command as:

::

	(ipengine &)
	
For some reason, running 'ipengine &' without the parentheses dones't work on some platforms.

If you have MPI installed, it is also possible to start the Engines using mpiexec:

::

	mpiexec -n 8 ipengine
	
Once the Controller and Engines have been started you ready to use them from a client.

Using the Controller and Engines from a Client
==============================================

The kernel interface is implemented in the kernelclient.py module.  This module
contains two main classes that allow the user to interact with the kernel:
RemoteKernel and InteractiveCluster.  This README focuses on parallel 
computations using the InteractiveCluster class, but the interface for working
with a single kernel (RemoteKernel) is almost identical.

Create an InteractiveCluster object
-----------------------------------

Begin by creating an InteractiveCluster object in IPython.  Then you tell the
object where two kernels are running and what ResultGatherer the kernels should
be notifying of results:

::

    In [1]: from ipython1.kernel1p.kernelclient import *

    In [2]: ic = InteractiveCluster()

    In [3]: ic.start([('127.0.0.1',10105),('127.0.0.1',10106)])
    Connecting to kernel:  ('127.0.0.1', 10105)
    Connecting to kernel:  ('127.0.0.1', 10106)
    Out[3]: True

    In [4]: ic.notify(('127.0.0.1',10104))

Now the InteractiveCluster object is ready to use.  If there is a problem 
connecting to the kernels, you either the kernels are not actually running
or you have a networking problems (like a closed firewall).

Executing commands on the kernels
---------------------------------

Python commands can be executed on the kernels using the execute() method:

::

    In [5]: ic.execute('a = 5')             # a = 5 on all kernels
    In [6]: ic.execute('b = 10')            # b = 10 on all kernels
    In [7]: ic.execute('c = 30',0)          # c = 30 on kernel 0
    In [8]: ic.execute('c = 40',1)          # d = 40 on kernel 1

You can also access individual kernsl using a list syntax:

::

    In [9]: ic[0].execute('d = 10')         # Same as execute('d=10',0)

Lastly, there are IPython magics for "parallel execution":

::

    In [10]: %px c = 30                     # Like execute('c = 30')
    Executing command on cluster

To have every command entered automatically prefixed by %px, enter 
autoparallel mode:

::

    In [11]: %autopx
    Auto Parallel Enabled

    In [12]: a = 40

    In [13]: b = 40

    In [14]: c = a + b

    In [15]: %autopx
    Auto Parallel Disabled

Every command entered while in autoparallel mode is executed on all kernels.

If you have more that one InteractiveCluster object, you can make a given one 
active for the %px magics using the activate command on the cluster:

::

    In [16]: ic.activate()

Moving python objecst around
----------------------------

In addition to being able to execute python code on the kernels, you can move
arbitrary (OK, not arbitrary, the objects need to be pickleable) python
objects around.  This is done using the push() and pull() methods:

::

    In [17]: ic.push('a',10)            # Send 10 to all kernels as 'a'

    In [18]: ic.pull('a')               # Pull 'a' back from all kernels
    Out[18]: [10, 10]

    In [19]: ic.pull('q')               # q is not defined
    Out[19]: [<NotDefined: q>, <NotDefined: q>]

In this form, push() acts like an MPI broadcast and pull acts like an MPI 
gather.  But push and pull support a much richer interface for more complicated
data movement:

::

    In [20]: ic.push('a',10,0)          # Push to only kernel 0
    
    In [21]: ic.push('a',20,1)          # Push to only kernel 1

    In [22]: ic.pull('a')               # Now gather from both
    Out[22]: [10, 20]

You can also give push and pull a list of kernel to work with:

::

    In [23]: ic.push('a',10,[0,1])

    In [24]: ic.pull('a',[0,1])
    Out[24]: [10, 10]

You can also use the list syntax:

::

    In [25]: ic[0].push('a',10)
    Out[25]: True

    In [26]: ic[0].pull('a')
    Out[26]: 10

Best of all, push and pull have convenient dictionary style interfaces:

::

    In [27]: ic['a'] = 10

    In [28]: ic['a']
    Out[28]: [10, 10]

    In [29]: ic[0]['b'] = 20

    In [30]: ic[1]['b'] = 20

    In [31]: ic['b']
    Out[31]: [20, 20]

You can partition and distribute a python sequence (an MPI scatter) to the 
kernels by pushing a Scatter object initialized with the sequence:

::

    In [5]: ic.push('a',Scatter(range(10)))

    In [6]: ic.pull('a')
    Out[6]: [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]

Or use the dictionary interface:

::

    In [7]: ic['a'] = Scatter(range(10))

By default, Scatter treats unit length sequences as lists:

::

    In [7]: ic['a'] = Scatter(range(2))

    In [8]: ic['a']
    Out[8]: [[0], [1]]

To scatter length one lists as scalars, set the flatten flag on the Scatter
object:

::

    In [9]: ic['a'] = Scatter(range(2),True)

    In [10]: ic['a']
    Out[10]: [0, 1]


**NOTE:**  While you can do things like ic[0]['a'] = ic[1]['b'], these types of data movements have not been optimized.  Currently the python object would come back to you  from kernel 1 and then be sent out to kernel 0.  Eventually we will implement a move() method for moving objects directly from one kernel to another.

**NOTE:**  Because push and pull use the pickle module, you cannot push and pull python functions to the kernels and back.

The map and parallelize commands
--------------------------------

With the basic commands (push, pull and execute) higher level constructs
can be build.  The map() and parallelize() methods of InteractiveCluster are
examples of this.

The map() method work just like the builtin python map, but the calling 
convention differs slightly.

::

    In [14]: map(lambda x: x*x,range(10))
    Out[14]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

The same thing on the cluster is called by giving the function to call
as a string:

::

    In [15]: ic.map('lambda x: x*x',range(10))
    Out[15]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

But, in this case, the sequence range(10) is scattered amongst the kernels
and then each kernel maps part of the list in parallel.  This is the most 
trivial way of parallelizing a simple algorithm. 

There are a number of similar ways of accomplishing the same thing:

::

    In [23]: ic.push('a', Scatter(range(10)))

    In [24]: %px b = [x*x for x in a]
    Executing command on cluster

    In [25]: ic.pull('a',flatten=True)
    Out[25]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

Or, there is a powerful VectorFunction object:

::

    In [26]: f = ic.parallelize('lambda x: x*x')

    In [27]: f(range(10))
    Out[27]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

The function f is a ParallelFunction object that exists in the local namespace.
It basically is a wrapper for the parallelized map() method of the cluster.

**NOTE:**  The functions used by map and parallelize must already be defined in the namespace of each kernel!  You cannot pass functions to the kernels.


Other commands
--------------

You can reset the kernel's namespaces:

::

    In [32]: ic.reset()

You can disconnect from the kernels:

::

    In [34]: ic.disconnect() 

Calling any method on the InteractiveCluster object that requires a kernel
connection will cause an automatic reconnect:

::

    In [35]: ic.execute('a = 5')
    Connecting to kernel:  ('127.0.0.1', 10105)
    Connecting to kernel:  ('127.0.0.1', 10106)

To kill the kernels for good, use kill():

::

    In [38]: ic.kill()

