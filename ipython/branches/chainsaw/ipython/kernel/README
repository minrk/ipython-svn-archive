Date:  9/5/2005
Author:  Brian E. Granger (bgranger@scu.edu)

This file gives an overview of the ipython kernel and the ipython kernel
interface layer.  Eventually, this README will contain basic information
and a tutorial describing to use the kernel.

For installation instructions, see the INSTALL file in this directory.

= Overview =

The ipython kernel opens up the door for the following:

1.  Interactive parallel computation in python.  

2.  A separation (into two or more processes) of the python user interface
    and the executetion of python code.
    
3.  Seamless support for the interactive use of multiple GUI toolkits.

4.  Collaborative computing and visualization.

The ipython kernel actually consists of two layers: the kernel and the kernel
interface.  The kernel is run in a separate process and consists of a
fully functional python interpreter that listen for python commands on a 
network port rather that a command line.  The kernel interface is run by
the user in a separate python interpreter.  The kernel interface 
consists of a set of python objects that allow the user to interact with one 
or more kernels simultaneously.  

= Basic Usage =

Using the ipython kernel involves three things.

== Starting the kernel ==

The basic ipython kernel is contained in the module kernel.py.  The 
kernel can be started using the command:

python kernel.py --port 10104 --allow 135.234.129.23

This starts the kernel listening on port 10104.  The kernel can be configured
to allow or deny connections from specific ip addresses.  The default is to 
allow connections from only the localhost (127.0.0.1).  To allow an additional 
ip address to connect to the kernel, use the option.

The basic kernel does not support interactive calls to GUI toolkits (tk, wx,
qt, Cocoa, etc.).  This is because each GUI toolkit has its own event loop that 
must be integrated with the event loop of the kernel (which uses twisted).  

To allow the interactive use of GUI toolkits, special purpose kernels are 
offered.  Currently, we have implemented a kernel that integrates with wx.
To start this kernel, use kernelwx.py rather than kernel.py in the above 
command.

Note: do not run the GUI kernel unless you really need it.  This is because
the GUI kernel lacks some of the features of the basic kernel.  Most importantly
the basic kernel is multithreaded and has a queue, whereas the GUI kernels have
only a single user thread an no queue.  The queue allow multiple python commands
to be sent to the kernel while previous commands are still executing.

== Controlling the kernels ==

The kernel interface is implemented in the kernelclient.py module.  This module
contains two main classes that allow the user to interact with the kernel:
RemoteKernel and InteractiveCluster.  To interact with a single kernel,
startup ipython (the current release) and create a RemoteKernel object:

from kernelclient import *

rk = RemoteKernel(('127.0.0.1',10105))

The (ip, port) tuple here is that of a running kernel.  Note, the kernel will 
not let you connect unless you are connecting from an allowed ip address.
From this point, you can interact with the kernel:

    rk.execute('a = 5')

    rk.push(10,'b')

    rk.pull('b')

If you get this far, consult the docstrings for the RemoteKernel class.

To interact with multiple kernels, create an InteractiveCluster object:

    ic = InteractiveCluster()

    ic.start([('127.0.0.1',10106),('127.0.0.1',10107)])

The InteractiveCluster class has a similar inteface as the RemoteKernel class.

=== Dictionary Interface ===

=== Magic inteface ===

== Monitoring the kernels ==

To monitor the stdin, stdout and stderr of the kernels, you must start a 
ResultGatherer class.  This class listens on a UDP port and receives UDP
datagrams from the kernels when results are ready.  To start this, in a separate
ipython session, run the following:

    from kernelclient import *

    rg = ResultGatherer(('127.0.0.1',10104))

    rg.start()

Now the ResultGatherer is ready to get results from kernels.  But you need to 
tell the kernels that they should send results to this ResultGatherer when
then are ready.  After you have created a RemoteKernel or InteractiveCluster
object, use the notify command:

    ic.notify(('127.0.0.1',10104))
 
Most importantly, multple people can monitor a cluster or kernel, even if those
people are not using the cluster or kernel currently.
