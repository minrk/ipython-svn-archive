Date:  9/5/2005
Author:  Brian E. Granger (bgranger@scu.edu)

This file gives an overview of the ipython kernel and the ipython kernel
interface layer.

For installation instructions, see the INSTALL file in this directory.

= Overview =

The ipython kernel opens up the door for the following:

1.  Interactive parallel computation in python.  

2.  A separation (into two or more processes) of the python user interface
    and the executetion of python code.
    
3.  Seamless support for the interactive use of multiple GUI toolkits.

4.  Collaborative computing and visualization.

The ipython kernel actually consists of two layers: the kernel and the kernel
interface.  The kernel is run in a separate process and consists of a
fully functional python interpreter that listen for python commands on a 
network port rather that a command line.  The kernel interface is run by
the user in a separate python interpreter.  The kernel interface 
consists of a set of python objects that allow the user to interact with one 
or more kernels simultaneously.  


= Basic Usage =


== Starting the kernel ==

The basic ipython kernel is contained in the module kernel.py.  The 
kernel can be started using the command:

    python kernel.py

NOTE: The kernel cannot be run in the background currently.  Thus is you try
python kernel.py &, the kernel will not work.  This has to do with the deep
inner workings of twisted.  In the future you will be able to do this.

Be default, the kernel listens on TCP port 10105.  To specify what TCP port
the kernel should listen on, use the -p (or --port) option:

    python kernel.py -p 10106

For security reasons, the kernel can be configured to allow or deny connections
from specific ip addresses.  The default is to allow connections from only the
localhost (127.0.0.1).  To allow an additional ip address to connect to the
kernel, use the option -a (or --allow):

    python kernel.py -p 10106 -a 168.169.170.171

Only a single additional ip address can be allowed at the command line.  To 
allow (deny) additional hosts to connect to the kernel see the allow (deny)
method of the RemoteKernel or InteractiveCluster classes.

The basic kernel does not support interactive calls to GUI toolkits (tk, wx,
qt, Cocoa, etc.).  This is because each GUI toolkit has its own event loop that 
must be integrated with the event loop of the kernel (which uses twisted).  

To allow the interactive use of GUI toolkits, special purpose kernels are 
offered.  Currently, we have implemented a kernel that integrates with wx.
To start this kernel, use kernelwx.py rather than kernel.py in the above 
command.  The GUI kernel accept the same command line options.

NOTE: Do not run the GUI kernel unless you really need it.  This is because
the GUI kernel lacks some of the features of the basic kernel.  Most importantly
the basic kernel is multithreaded and has a queue, whereas the GUI kernels have
only a single user thread and no queue.  The queue allow multiple python 
commands to be sent to the kernel while previous commands are still executing.


== Controlling the kernels ==

The kernel interface is implemented in the kernelclient.py module.  This module
contains two main classes that allow the user to interact with the kernel:
RemoteKernel and InteractiveCluster.  To interact with a single kernel,
startup ipython (the current release) and create a RemoteKernel object:

from kernelclient import *

rk = RemoteKernel(('127.0.0.1',10105))

The (ip, port) tuple here is that of a running kernel.  Note, the kernel will 
not let you connect unless you are connecting from an allowed ip address.
From this point, you can interact with the kernel:

    rk.execute('a = 5')

    rk.push(10,'b')

    rk.pull('b')

If you get this far, consult the docstrings for the RemoteKernel class.

To interact with multiple kernels, create an InteractiveCluster object:

    ic = InteractiveCluster()

    ic.start([('127.0.0.1',10106),('127.0.0.1',10107)])

The InteractiveCluster class has a similar inteface as the RemoteKernel class.

=== Dictionary Interface ===

=== Magic inteface ===

== Monitoring the kernels ==

To monitor the stdin, stdout and stderr of the kernels, you must start a 
ResultGatherer class.  This class listens on a UDP port and receives UDP
datagrams from the kernels when results are ready.  To start this, in a separate
ipython session, run the following:

    from kernelclient import *

    rg = ResultGatherer(('127.0.0.1',10104))

    rg.start()

Now the ResultGatherer is ready to get results from kernels.  But you need to 
tell the kernels that they should send results to this ResultGatherer when
then are ready.  After you have created a RemoteKernel or InteractiveCluster
object, use the notify command:

    ic.notify(('127.0.0.1',10104))
 
Most importantly, multple people can monitor a cluster or kernel, even if those
people are not using the cluster or kernel currently.
