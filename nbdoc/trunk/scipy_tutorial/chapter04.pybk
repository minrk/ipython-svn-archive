<notebook version="1"><head/><ipython-log id="default-log"/><sheet id="chapter04">
<title>Integration (integrate)</title>
<para>The integrate sub-package provides several integration techniques
including an ordinary differential equation integrator. An overview of the
module is provided by the help command:
</para>
<programlisting>XXX: ipython
&gt;&gt;&gt; help(integrate)
Methods for Integrating Functions

  odeint        -- Integrate ordinary differential equations.
  quad          -- General purpose integration.
  dblquad       -- General purpose double integration.
  tplquad       -- General purpose triple integration.
  gauss_quad    -- Integrate func(x) using Gaussian quadrature of order n.
  gauss_quadtol -- Integrate with given tolerance using Gaussian quadrature.

  See the orthogonal module (integrate.orthogonal) for Gaussian
     quadrature roots and weights.
</programlisting>
<section>
<title>General integration (integrate.quad)</title>
<para>The function quad is provided to integrate a function of one variable
between two points. The points can be 
<ipython-inlineequation>\pm\infty</ipython-inlineequation>
(<ipython-inlineequation>\pm</ipython-inlineequation> integrate.inf) to indicate
infinite limits. For example, suppose you wish to integrate a bessel function
<code>jv(2.5,x)</code> along the interval [0,4.5]. 
<ipython-equation>I=\int_{0}^{4.5}J_{2.5}\left(x\right)\,dx</ipython-equation>.
This could be computed using quad:
</para>
<programlisting>XXX: ipython
&gt;&gt;&gt; result = integrate.quad(lambda x: special.jv(2.5,x), 0, 4.5)
&gt;&gt;&gt; print result
(1.1178179380783249, 7.8663172481899801e-09)

&gt;&gt;&gt; I = sqrt(2/pi)*(18.0/27*sqrt(2)*cos(4.5)-4.0/27*sqrt(2)*sin(4.5)+
    sqrt(2*pi)*special.fresnl(3/sqrt(pi))[0])
&gt;&gt;&gt; print I
1.117817938088701

&gt;&gt;&gt; print abs(result[0]-I)
1.03761443881e-11 
</programlisting>
<para>The first argument to quad is a "callable" Python object (i.e a function,
method, or class instance). Notice the use of a lambda-function in this case as
the argument. The next two arguments are the limits of integration. The return
value is a tuple, with the first element holding the estimated value of the
integral and the second element holding an upper bound on the error. Notice,
that in this case, the true value of this integral is
<ipython-equation>
I=\sqrt{\frac{2}{\pi}}\left(\frac{18}{27}\sqrt{2}\cos\left(4.5\right)-\frac{4}{27}\sqrt{2}\sin\left(4.5\right)+\sqrt{2\pi}\textrm{Si}\left(\frac{3}{\sqrt{\pi}}\right)\right),
</ipython-equation>
where
<ipython-equation>
\textrm{Si}\left(x\right)=\int_{0}^{x}\sin\left(\frac{\pi}{2}t^{2}\right)\, dt
</ipython-equation>.
is the Fresnel sine integral. Note that the numerically-computed integral is
within <ipython-inlineequation>1.04\times10^{-11}</ipython-inlineequation> of
the exact result --- well below the reported error
bound. 
</para>
<para>Infinite inputs are also allowed in quad by using 
<ipython-inlineequation>\pm</ipython-inlineequation> integrate.inf (or
inf) as one of the arguments. For example, suppose that a numerical value for
the exponential
integral:
<ipython-equation>E_{n}\left(x\right)=\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt
</ipython-equation>. is
desired (and the fact that this integral can be computed as special.expn(n,x) is
forgotten). The functionality of the function special.expn can be replicated by
defining a new function vec_expint based on the routine quad: 
</para>
<programlisting> XXX: ipython
&gt;&gt;&gt; from integrate import quad, Inf
&gt;&gt;&gt; def integrand(t,n,x):
        return exp(-x*t) / t**n

&gt;&gt;&gt; def expint(n,x): 
        return quad(integrand, 1, Inf, args=(n, x))[0]

&gt;&gt;&gt; vec_expint = vectorize(expint)

&gt;&gt;&gt; vec_expint(3,arange(1.0,4.0,0.5))
array([ 0.1097,  0.0567,  0.0301,  0.0163,  0.0089,  0.0049])
&gt;&gt;&gt; special.expn(3,arange(1.0,4.0,0.5))
array([ 0.1097,  0.0567,  0.0301,  0.0163,  0.0089,  0.0049])
</programlisting>
<para>The function which is integrated can even use the quad argument (though
the error bound may underestimate the error due to possible numerical error in
the integrand from the use of quad). The integral in this case is
<ipython-equation>
I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\,
dx=\frac{1}{n}</ipython-equation>.
</para>
<programlisting>XXX: ipython
&gt;&gt;&gt; result = quad(lambda x: expint(3, x), 0, Inf)
&gt;&gt;&gt; print result
(0.33333333324560266, 2.8548934485373678e-09)  

&gt;&gt;&gt; I3 = 1.0/3.0
&gt;&gt;&gt; print I3
0.333333333333   

&gt;&gt;&gt; print I3 - result[0]
8.77306560731e-11     
</programlisting>
<para>This last example shows that multiple integration can be handled using
repeated calls to quad. The mechanics of this for double and triple integration
have been wrapped up into the functions dblquad and tplquad. The function,
dblquad performs double integration. Use the help function to be sure that the
arguments are defined in the correct order. In addition, the limits on all inner
integrals are actually functions which can be constant functions. An example of
using double integration to compute several values of
<ipython-inlineequation>I_{n}</ipython-inlineequation> is shown below:
</para>
<programlisting>XXX: ipython
&gt;&gt;&gt; from __future__ import nested_scopes
&gt;&gt;&gt; from integrate import quad, dblquad, Inf
&gt;&gt;&gt; def I(n):
    return dblquad(lambda t, x: exp(-x*t)/t**n, 0, Inf, lambda x: 1, lambda x: Inf) 

&gt;&gt;&gt; print I(4)
(0.25000000000435768, 1.0518245707751597e-09)
&gt;&gt;&gt; print I(3)
(0.33333333325010883, 2.8604069919261191e-09) 
&gt;&gt;&gt; print I(2)
(0.49999999999857514, 1.8855523253868967e-09)
</programlisting>
</section>
<section>
<title>Gaussian quadrature (integrate.gauss_quadtol)</title>
<para>A few functions are also provided in order to perform simple Gaussian
quadrature over a fixed interval. The first is fixed_quad which performs
fixed-order Gaussian quadrature. The second function is quadrature which
performs Gaussian quadrature of multiple orders until the difference in the
integral estimate is beneath some tolerance supplied by the user. These
functions both use the module special.orthogonal which can calculate the roots
and quadrature weights of a large variety of orthogonal polynomials (the
polynomials themselves are available as special functions returning instances of
the polynomial class --- e.g. special.legendre). 
</para>
</section>
<section>
<title>Integrating using samples</title>
<para>There are three functions for computing integrals given only samples:
trapz, simps, and romb. The first two functions use Newton-Coates formulas of
order 1 and 2 respectively to perform integration. These two functions can
handle, non-equally-spaced samples. The trapezoidal rule approximates the
function as a straight line between adjacent points, while Simpson's rule
approximates the function between three adjacent points as a parabola. 
</para>
<para>If the samples are equally-spaced and the number of samples available is
<ipython-inlineequation>2^{k}+1</ipython-inlineequation> for some integer 
<ipython-inlineequation>k</ipython-inlineequation>, then Romberg integration can be used to obtain
high-precision estimates of the integral using the available samples. Romberg
integration uses the trapezoid rule at step-sizes related by a power of two and
then performs Richardson extrapolation on these estimates to approximate the
integral with a higher-degree of accuracy. (A different interface to Romberg
integration useful when the function can be provided is also available as
integrate.romberg). 
</para>
</section>
<section>
<title>Ordinary differential equations (integrate.odeint)</title>
<para>Integrating a set of ordinary differential equations (ODEs) given initial
conditions is another useful example. The function odeint is available in SciPy
for integrating a first-order vector differential
equation:
<ipython-equation>\frac{d\mathbf{y}}{dt}=\mathbf{f}\left(\mathbf{y},t\right),</ipython-equation> 
given
initial conditions
<ipython-inlineequation>\mathbf{y}\left(0\right)=y_{0}</ipython-inlineequation>, where 
<ipython-inlineequation>\mathbf{y}</ipython-inlineequation> is a length
<ipython-inlineequation>N</ipython-inlineequation> vector and 
<ipython-inlineequation>\mathbf{f}</ipython-inlineequation> is a mapping from 
<ipython-inlineequation>\mathcal{R}^{N}</ipython-inlineequation> to 
<ipython-inlineequation>\mathcal{R}^{N}</ipython-inlineequation>. A
higher-order ordinary differential equation can always be reduced to a
differential equation of this type by introducing intermediate derivatives into
the <ipython-inlineequation>\mathbf{y}</ipython-inlineequation> vector. 
</para>
<para>
For example suppose it is desired to find the solution to the following
second-order differential equation:
<ipython-equation>\frac{d^{2}w}{dz^{2}}-zw(z)=0</ipython-equation> with initial
conditions
<ipython-inlineequation>w\left(0\right)=\frac{1}{\sqrt[3]{3^{2}}\Gamma\left(\frac{2}{3}\right)}</ipython-inlineequation> and
<ipython-inlineequation>\left.\frac{dw}{dz}\right|_{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma\left(\frac{1}{3}\right)}</ipython-inlineequation>.
It is known that the solution to this differential equation with these boundary
conditions is the Airy function <ipython-equation>w=\textrm{Ai}\left(z\right)</ipython-equation>, which gives a means
to check the integrator using special.airy. 
</para>
<para>
First, convert this ODE into standard form by setting
<ipython-inlineequation>\mathbf{y}=\left[\frac{dw}{dz},w\right]</ipython-inlineequation>
and <ipython-inlineequation>t=z</ipython-inlineequation>. Thus, the differential equation
becomes
<ipython-equation>\frac{d\mathbf{y}}{dt}=\left[\begin{array}{c}
ty_{1}\\
y_{0}\end{array}\right]=\left[\begin{array}{cc}
0 &amp; t\\
1 &amp; 0\end{array}\right]\left[\begin{array}{c}
y_{0}\\
y_{1}\end{array}\right]=\left[\begin{array}{cc}
0 &amp; t\\
1 &amp; 0\end{array}\right]\mathbf{y}.</ipython-equation> 
In other words,
<ipython-equation>\mathbf{f}\left(\mathbf{y},t\right)=\mathbf{A}\left(t\right)\mathbf{y}. 
</ipython-equation>
</para>
<para>
As an interesting reminder, if
<ipython-inlineequation>\mathbf{A}\left(t\right)</ipython-inlineequation> commutes with
<ipython-inlineequation>\int_{0}^{t}\mathbf{A}\left(\tau\right)\,
d\tau</ipython-inlineequation>  under matrix multiplication,
then this linear differential equation has an exact solution using the matrix
exponential:
<ipython-equation>
\mathbf{y}\left(t\right)=\exp\left(\int_{0}^{t}\mathbf{A}\left(\tau\right)d\tau\right)\mathbf{y}\left(0\right),
</ipython-equation>
However, in this case,
<ipython-inlineequation>\mathbf{A}\left(t\right)</ipython-inlineequation> and its integral do not commute.
</para>
<para>
There are many optional inputs and outputs available when using odeint which can
help tune the solver. These additional inputs and outputs are not needed much of
the time, however, and the three required input arguments and the output
solution suffice. The required inputs are the function defining the derivative,
fprime, the initial conditions vector, y0, and the time points to obtain a
solution, t, (with the initial value point as the first element of this
sequence). The output to odeint is a matrix where each row contains the solution
vector at each requested time point (thus, the initial conditions are given in
the first output row). 
</para>
<para>
The following example illustrates the use of odeint including the usage of the
Dfun option which allows the user to specify a gradient (with respect to
<ipython-inlineequation>\mathbf{y}</ipython-inlineequation>) of the function,
<ipython-inlineequation>\mathbf{f}\left(\mathbf{y},t\right)</ipython-inlineequation>.
</para>
<programlisting>XXX: ipython
&gt;&gt;&gt; from integrate import odeint
&gt;&gt;&gt; from special import gamma, airy
&gt;&gt;&gt; y1_0 = 1.0/3**(2.0/3.0)/gamma(2.0/3.0)
&gt;&gt;&gt; y0_0 = -1.0/3**(1.0/3.0)/gamma(1.0/3.0)
&gt;&gt;&gt; y0 = [y0_0, y1_0]
&gt;&gt;&gt; def func(y, t):
        return [t*y[1],y[0]]

&gt;&gt;&gt; def gradient(y,t):
        return [[0,t],[1,0]]

&gt;&gt;&gt; x = arange(0,4.0, 0.01)
&gt;&gt;&gt; t = x
&gt;&gt;&gt; ychk = airy(x)[0]
&gt;&gt;&gt; y = odeint(func, y0, t)
&gt;&gt;&gt; y2 = odeint(func, y0, t, Dfun=gradient)

&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.float_output_precision = 6
&gt;&gt;&gt; print ychk[:36:6]
[ 0.355028  0.339511  0.324068  0.308763  0.293658  0.278806]

&gt;&gt;&gt; print y[:36:6,1]
[ 0.355028  0.339511  0.324067  0.308763  0.293658  0.278806]

&gt;&gt;&gt; print y2[:36:6,1]
[ 0.355028  0.339511  0.324067  0.308763  0.293658  0.278806]
</programlisting>

</section>
</sheet></notebook>
